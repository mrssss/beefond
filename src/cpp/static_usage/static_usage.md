# static关键字的四种用法

## 1.修饰函数内静态变量

在函数内部使用static修饰变量时，会延长这个变量的生命周期。

```c
{{ #include ./method.cpp }}
```

编译文件`g++ -S method.cpp -O0`，得到没有优化过的汇编代码

```c
{{ #include ./method.s }}
```

可以看到在全局的`.data`段中有一个label `_ZZ6methodvE1i`。

我们知道，`.data`段是程序的全局内存空间，而不是在函数的调用栈中。

通过这个实验我们可以看到，在函数中对变量使用static关键字，可以将
该变量移到全局内存空间中，这样该变量就获得了和全局变量一样的生命周
期；在程序加载的时候就会给它分配好内存，在程序运行结束的时候才会释
放掉这段内存。

而又因为这个变量的是在函数体的花括号中定义的，所以它的作用域被限定
在了这个花括号中。这意味着这个变量在程序的其他位置时不可见的。

同时，因为这个变量被放在了全局变量，而不是和普通局部变量一样放在函
数调用栈中。在并发编程中，这个变量变成了共享内存。这就导致它所在的
函数成为了有状态的函数，变成了不可重入的、非线程安全的函数。

## 2.限制标识符为文件作用域

在函数体之外（文件级别）使用static修饰标识符（变量或函数）会让这个
标识符仅在本文件中可见，或者说这些符号具有内部链接性（internal 
linkage）。

```c
{{ #include ./file.cpp }}
```

这一次，把源文件编译成二进制文件，通过`objdump -t file.o`指令来
查看符号属性。

```c
{{ #include ./file.symbol }}
```

可以看到`_ZL11func_staticv`符号的属性是`l` local，而`_Z4funcv`
的属性是`g` global。
链接器在链接的时候只会在本编译单元中对这个符号进行地址重排，其他编译
单元会忽略掉这个标识符。

## 3.修饰类中静态成员

类中的态成员被直接当做全局变量来处理，只不过它被限定在类的命名空间中。

静态成员是被所有同一个类的对象所共享的变量。

## 4.修饰静态成员函数

static可以修饰函数，使其成为“静态成员函数”。静态成员函数只能够访问
类变量和其他的静态成员函数，不能访问普通成员变量和普通成员方法。

对于普通成员方法来讲，在调用的时候，第一个参数会传对象的地址。而静态
方法不和对象绑定，不需要传对象地址。同样，它也就没有办法访问到普通成
员变量和普通成员方法。

```c
{{ #include ./cls.cpp }}
```

```c
{{ #include ./cls.s }}
```

# 匿名namespace

匿名namespace用于编译单元级别的信息隐藏。匿名namespace中定义的名字，
只在相同的编译单元中可以被看到。编译器会给这个命名空间生成一个唯一的名字。
这样和static修饰标识符有同样的效果。

```cpp
{{ #include ./ns.cpp }}
```

```c
{{ #include ./ns.s }}
```

```c
{{ #include ./ns.symbol }}
```

匿名namespace和static不太一样的地方在于，它对于类型的定义也是有效的。
所以在C++中，一般推荐使用匿名namespace而不是static。
