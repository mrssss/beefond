# 指针101

## 声明指针
`*`将变量声明为指针。
类型 `*` 变量名。
```c
type * var;
```

## `*`运算符重载

### 乘法运算符
```c
10 * 20
```

### 声明指针
```c
int a = 10;
int * p = &a;
```

### 解引用指针
使用指针变量来访问指针变量存储的地址指向的对象。
```c
*p = 20;
```

## 阅读指针相关声明
在阅读指针的声明时，从右向左读，会更加容易一些

例1:
```c
const int* a;
```

指针所指向的内容是常量不可变
(不可以通过指针改变它，并不是他本身不可以作为左值）

例2:
```c
int * const a;
```

指针本身是常量不可变，只能指向它。

例3:
```c
const int * const a;
```

两者都不可变

例4:
```c
const int ** a;
```

`a`是一个指向`const int *`指针的指针

例5:
```c
int ** const a；
```

`a`是一个指向`int*`的指针，且`a`被`const`修饰，本身是常量不可变

## 取地址
```c
int a = 10;
int * p = &a;
```

给指针赋值的时候要求，指针指向的对象类型相同，
```c
float a = 10;
int * p = &a;
```

如果指针和地址指向的对象的类型不匹配，编译器会报错，
```
error: cannot convert ‘float*’ to ‘int*’ in initialization
    2 | int * p = &a;
      |           ^~
      |           |
      |           float*
```

## NULL
NULL值意味着指针不指向任何对象。
一般定义如下
```c
#define NULL  ((void *)0)
```

## `void *`指针
`void *`是通用指针类型，它去掉了指针指向的对象的类型属性。
可以用来存放任何数据类型的地址。

* 任何指针都可以被赋值给`void *`指针，`void *`指针也可以被转换成其他类型的指针
* `void *`类型指针指可以用作数据指针，不能用作函数指针

不应该对`void *`指针进行整数加减运算，这样做没有意义，而且编译器也会报警告信息。


## 虚拟内存
对于运行在操作系统上的应用程序来讲，指针中的地址一般不是实际的物理地址。

应用程序使用的是经过映射的虚拟地址，虚拟地址不会改变，
而实际的地址会被操作系统映射到不同的物理内存地址。
一般来说，程序员也不需要关心实际的物理地址是什么。